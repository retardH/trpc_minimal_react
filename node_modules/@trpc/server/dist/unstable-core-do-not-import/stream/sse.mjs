import { getTRPCErrorFromUnknown } from '../error/TRPCError.mjs';
import { run, identity } from '../utils.mjs';
import { isTrackedEnvelope } from './tracked.mjs';
import { withCancel, takeWithGrace } from './utils/asyncIterable.mjs';
import { createReadableStream } from './utils/createReadableStream.mjs';
import { createPromiseTimer } from './utils/promiseTimer.mjs';
import { withPing, PING_SYM } from './utils/withPing.mjs';

const SERIALIZED_ERROR_EVENT = 'serialized-error';
/**
 *
 * @see https://html.spec.whatwg.org/multipage/server-sent-events.html
 */ function sseStreamProducer(opts) {
    const stream = createReadableStream();
    stream.controller.enqueue({
        comment: 'connected'
    });
    const { serialize =identity  } = opts;
    const ping = {
        enabled: opts.ping?.enabled ?? false,
        intervalMs: opts.ping?.intervalMs ?? 1000
    };
    run(async ()=>{
        let iterable = opts.data;
        iterable = withCancel(iterable, stream.cancelledPromise);
        if (opts.emitAndEndImmediately) {
            iterable = takeWithGrace(iterable, {
                count: 1,
                gracePeriodMs: 1,
                onCancel: ()=>opts.abortCtrl.abort()
            });
        }
        let maxDurationTimer = null;
        if (opts.maxDurationMs != null && opts.maxDurationMs > 0 && opts.maxDurationMs !== Infinity) {
            maxDurationTimer = createPromiseTimer(opts.maxDurationMs).start();
            iterable = withCancel(iterable, maxDurationTimer.promise.then(()=>opts.abortCtrl.abort()));
        }
        if (ping.enabled && ping.intervalMs !== Infinity && ping.intervalMs > 0) {
            iterable = withPing(iterable, ping.intervalMs);
        }
        try {
            // We need those declarations outside the loop for garbage collection reasons. If they were
            // declared inside, they would not be freed until the next value is present.
            let value;
            let chunk;
            for await (value of iterable){
                if (value === PING_SYM) {
                    stream.controller.enqueue({
                        comment: 'ping'
                    });
                    continue;
                }
                chunk = isTrackedEnvelope(value) ? {
                    id: value[0],
                    data: value[1]
                } : {
                    data: value
                };
                if ('data' in chunk) {
                    chunk.data = JSON.stringify(serialize(chunk.data));
                }
                stream.controller.enqueue(chunk);
                // free up references for garbage collection
                value = null;
                chunk = null;
            }
        } catch (err) {
            // ignore abort errors, send any other errors
            if (!(err instanceof Error) || err.name !== 'AbortError') {
                // `err` must be caused by `opts.data`, `JSON.stringify` or `serialize`.
                // So, a user error in any case.
                const error = getTRPCErrorFromUnknown(err);
                const data = opts.formatError?.({
                    error
                }) ?? null;
                stream.controller.enqueue({
                    event: SERIALIZED_ERROR_EVENT,
                    data: JSON.stringify(serialize(data))
                });
            }
        } finally{
            maxDurationTimer?.clear();
            stream.controller.close();
        }
    }).catch((err)=>{
        // should not be reached; just in case...
        stream.controller.error(err);
    });
    return stream.readable.pipeThrough(new TransformStream({
        transform (chunk, controller) {
            if ('event' in chunk) {
                controller.enqueue(`event: ${chunk.event}\n`);
            }
            if ('data' in chunk) {
                controller.enqueue(`data: ${chunk.data}\n`);
            }
            if ('id' in chunk) {
                controller.enqueue(`id: ${chunk.id}\n`);
            }
            if ('comment' in chunk) {
                controller.enqueue(`: ${chunk.comment}\n`);
            }
            controller.enqueue('\n\n');
        }
    }));
}
/**
 * @see https://html.spec.whatwg.org/multipage/server-sent-events.html
 */ function sseStreamConsumer(opts) {
    const { deserialize =(v)=>v  } = opts;
    const signal = opts.signal;
    let _es = null;
    const stream = new ReadableStream({
        async start (controller) {
            const [url, init] = await Promise.all([
                opts.url(),
                opts.init()
            ]);
            const eventSource = _es = new opts.EventSource(url, init);
            controller.enqueue({
                type: 'connecting',
                eventSource: _es,
                event: null
            });
            eventSource.addEventListener('open', ()=>{
                controller.enqueue({
                    type: 'opened',
                    eventSource
                });
            });
            eventSource.addEventListener(SERIALIZED_ERROR_EVENT, (_msg)=>{
                const msg = _msg;
                controller.enqueue({
                    type: 'serialized-error',
                    error: deserialize(JSON.parse(msg.data)),
                    eventSource
                });
            });
            eventSource.addEventListener('error', (event)=>{
                if (eventSource.readyState === EventSource.CLOSED) {
                    controller.error(event);
                } else {
                    controller.enqueue({
                        type: 'connecting',
                        eventSource,
                        event
                    });
                }
            });
            eventSource.addEventListener('message', (_msg)=>{
                const msg = _msg;
                const chunk = deserialize(JSON.parse(msg.data));
                const def = {
                    data: chunk
                };
                if (msg.lastEventId) {
                    def.id = msg.lastEventId;
                }
                controller.enqueue({
                    type: 'data',
                    data: def,
                    eventSource
                });
            });
            const onAbort = ()=>{
                controller.close();
                eventSource.close();
            };
            if (signal.aborted) {
                onAbort();
            } else {
                signal.addEventListener('abort', onAbort);
            }
        },
        cancel () {
            _es?.close();
        }
    });
    return {
        [Symbol.asyncIterator] () {
            const reader = stream.getReader();
            const iterator = {
                async next () {
                    const value = await reader.read();
                    if (value.done) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    return {
                        value: value.value,
                        done: false
                    };
                },
                async return () {
                    reader.releaseLock();
                    return {
                        value: undefined,
                        done: true
                    };
                }
            };
            return iterator;
        }
    };
}
const sseHeaders = {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache, no-transform',
    'X-Accel-Buffering': 'no',
    Connection: 'keep-alive'
};

export { sseHeaders, sseStreamConsumer, sseStreamProducer };
