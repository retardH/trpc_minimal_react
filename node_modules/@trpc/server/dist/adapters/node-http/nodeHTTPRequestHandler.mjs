import { getErrorShape } from '../../unstable-core-do-not-import/error/getErrorShape.mjs';
import { getTRPCErrorFromUnknown } from '../../unstable-core-do-not-import/error/TRPCError.mjs';
import { run } from '../../unstable-core-do-not-import/utils.mjs';
import { resolveResponse } from '../../unstable-core-do-not-import/http/resolveResponse.mjs';
import '../../unstable-core-do-not-import/rootConfig.mjs';
import { transformTRPCResponse } from '../../unstable-core-do-not-import/transformer.mjs';
import { incomingMessageToRequest } from './incomingMessageToRequest.mjs';

/**
 * If you're making an adapter for tRPC and looking at this file for reference, you should import types and functions from `@trpc/server` and `@trpc/server/http`
 *
 * @example
 * ```ts
 * import type { AnyTRPCRouter } from '@trpc/server'
 * import type { HTTPBaseHandlerOptions } from '@trpc/server/http'
 * ```
 */ // @trpc/server
/**
 * @internal
 */ function internal_exceptionHandler(opts) {
    return (cause)=>{
        const { res , req  } = opts;
        const error = getTRPCErrorFromUnknown(cause);
        const shape = getErrorShape({
            config: opts.router._def._config,
            error,
            type: 'unknown',
            path: undefined,
            input: undefined,
            ctx: undefined
        });
        opts.onError?.({
            req,
            error,
            type: 'unknown',
            path: undefined,
            input: undefined,
            ctx: undefined
        });
        const transformed = transformTRPCResponse(opts.router._def._config, {
            error: shape
        });
        res.statusCode = shape.data.httpStatus;
        res.end(JSON.stringify(transformed));
    };
}
/**
 * @remark the promise never rejects
 */ async function nodeHTTPRequestHandler(opts) {
    return new Promise((resolve)=>{
        const handleViaMiddleware = opts.middleware ?? ((_req, _res, next)=>next());
        opts.res.once('finish', ()=>{
            resolve();
        });
        return handleViaMiddleware(opts.req, opts.res, (err)=>{
            run(async ()=>{
                const req = incomingMessageToRequest(opts.req, {
                    maxBodySize: opts.maxBodySize ?? null
                });
                // Build tRPC dependencies
                const createContext = async (innerOpts)=>{
                    return await opts.createContext?.({
                        ...opts,
                        ...innerOpts
                    });
                };
                const response = await resolveResponse({
                    ...opts,
                    req,
                    error: err ? getTRPCErrorFromUnknown(err) : null,
                    createContext,
                    onError (o) {
                        opts?.onError?.({
                            ...o,
                            req: opts.req
                        });
                    }
                });
                const { res  } = opts;
                if (res.statusCode === 200) {
                    // if the status code is set, we assume that it's been manually overridden
                    res.statusCode = response.status;
                }
                for (const [key, value] of response.headers){
                    res.setHeader(key, value);
                }
                if (response.body) {
                    const reader = response.body.getReader();
                    const onAbort = ()=>{
                        // cancelling the reader will cause the whole stream to be cancelled
                        reader.cancel().catch(()=>{
                        // console.error('reader.cancel() error', err);
                        });
                    };
                    req.signal.addEventListener('abort', onAbort, {
                        once: true
                    });
                    while(true){
                        const { done , value: value1  } = await reader.read();
                        if (done) {
                            break;
                        }
                        if (!res.writable) {
                            break;
                        }
                        if (res.write(value1) === false) {
                            await new Promise((resolve)=>{
                                res.once('drain', resolve);
                            });
                        }
                        // useful for debugging chunked responses:
                        // console.log('wrote', Buffer.from(value).toString());
                        // IMPORTANT - flush the response buffer, otherwise the client will not receive the data until `.end()`
                        res.flush?.();
                    }
                    req.signal.removeEventListener('abort', onAbort);
                }
                res.end();
            }).catch(internal_exceptionHandler(opts));
        });
    });
}

export { internal_exceptionHandler, nodeHTTPRequestHandler };
